<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Gaussian Arc Edge - Final</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; font-family: sans-serif; }
        canvas { display: block; }
        #ui-overlay { position: absolute; top: 10px; left: 10px; z-index: 10; display: flex; gap: 10px; }
        button { padding: 12px 20px; font-size: 16px; cursor: pointer; background-color: #007bff; color: white; border: none; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.2); }
        button:disabled { background-color: #555; color: #aaa; cursor: not-allowed; }
        #status { position: absolute; bottom: 10px; left: 10px; color: white; background-color: rgba(0,0,0,0.75); padding: 10px; border-radius: 5px; font-family: monospace; z-index: 10; line-height: 1.5; font-size: 11px; }
    </style>
</head>
<body>
    <div id="ui-overlay">
        <button id="calibrate-btn">Calibrate Sensors</button>
        <button id="activate-btn">Activate Gaussian Arc Edge</button>
    </div>
    <div id="status">Status: Awaiting Calibration</div>
    <video id="video" muted playsinline style="display:none"></video>

    <script type="x-shader/x-vertex" id="vertexShader">
        varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }
    </script>
    <script type="x-shader/x-fragment" id="fragmentShader">
        uniform sampler2D uObjectTexture; uniform sampler2D uDepthMask; uniform vec2 uResolution; varying vec2 vUv;
        void main() { vec2 screenUv = gl_FragCoord.xy / uResolution.xy; float maskValue = texture2D(uDepthMask, screenUv).r; if (maskValue > 0.5) { discard; } gl_FragColor = texture2D(uObjectTexture, vUv); }
    </script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/suncalc/1.8.0/suncalc.min.js"></script>
    
    <script>
        let scene, camera, renderer, digitalAsset, ambientLight, directionalLight;
        let arModeActive = false, isCalibrating = false, calibrationStartTime = 0;
        let startOrientation = { alpha: null, beta: null }, currentOrientation = { alpha: 0, beta: 0 };
        let maxPanAngle = 0;
        const CALIBRATION_TIME_REQ = 5, CALIBRATION_PAN_REQ = 45;

        const videoElement = document.getElementById('video');
        const calibrateButton = document.getElementById('calibrate-btn');
        const activateButton = document.getElementById('activate-btn');
        const statusElement = document.getElementById('status');
        
        // --- Gaussian Arc Edge Processor (v12 - Graduated Low-Light Analysis) ---
        const GaussianArcEdgeProcessor = {
            isInitialized: false, isCalibrated: false,
            config: {
                day:   { brightnessOffset: 110.0, occlusionDistance: 70.0 },
                night: { brightnessOffset: 90.0,  occlusionDistance: 60.0 }
            },
            isDayTime: true,
            lowLightModeThreshold: 40.0, // Pixels darker than this use the memory-based analysis.

            calibrationData: { ambientBackground:{r:0,g:0,b:0,brightness:0}, stableShadowPoint:{r:0,g:0,b:0,brightness:0} },
            
            canvas: document.createElement('canvas'), ctx: null, maskTexture: null,
            postProcessCanvas: document.createElement('canvas'), postProcessCtx: null,

            // [UPDATED] Habitat objects now store their last known good state.
            habitats: new Map(),
            
            farZoneAmbient: {r:0,g:0,b:0,brightness:0}, farZoneShadow: {r:0,g:0,b:0,brightness:0},
            brightestPoint: { x: 0.5, y: 0.5 }, dynamicLightThreshold: 0, smoothingFactor: 0.05,
            
            resetState() { /*...*/ this.isInitialized=false;this.isCalibrated=false;this.calibrationData={ambientBackground:{r:0,g:0,b:0,brightness:0},stableShadowPoint:{r:0,g:0,b:0,brightness:0}};this.farZoneAmbient={r:0,g:0,b:0,brightness:0};this.farZoneShadow={r:0,g:0,b:0,brightness:0};this.habitats.clear();console.log("State reset.");},
            init(useCal) { this.resetState();this.ctx=this.canvas.getContext('2d',{willReadFrequently:true});this.postProcessCtx=this.postProcessCanvas.getContext('2d');if(useCal){this.isCalibrated=true;Object.assign(this.farZoneAmbient,this.calibrationData.ambientBackground);Object.assign(this.farZoneShadow,this.calibrationData.stableShadowPoint);}this.isInitialized=true;},
            lerp: (s, e, a) => (1-a)*s+a*e,
            colorDistance: (c1,c2) => Math.sqrt((c1.r-c2.r)**2+(c1.g-c2.g)**2+(c1.b-c2.b)**2),

            analyzeCameraFrame(sourceVideo) {
                if(!this.isInitialized||sourceVideo.paused||sourceVideo.ended)return null;const w=this.canvas.width=sourceVideo.videoWidth,h=this.canvas.height=sourceVideo.videoHeight;if(!w||!h)return null;this.ctx.drawImage(sourceVideo,0,0,w,h);const data=this.ctx.getImageData(0,0,w,h).data;
                const activeConfig=this.isDayTime?this.config.day:this.config.night;
                
                // === PASS 1: LEARN BACKGROUND RANGE ===
                // [Unchanged - This logic is solid]
                const fzeY=h*0.3;let fzP=[];for(let y=0;y<fzeY;y++){for(let x=0;x<w;x++){const i=(y*w+x)*4,r=data[i],g=data[i+1],b=data[i+2];fzP.push({r,g,b,brightness:(r+g+b)/3});}}
                if(fzP.length>0){let cA={r:0,g:0,b:0,brightness:0};fzP.forEach(p=>{cA.r+=p.r;cA.g+=p.g;cA.b+=p.b;cA.brightness+=p.brightness;});Object.keys(cA).forEach(k=>cA[k]/=fzP.length);fzP.sort((a,b)=>a.brightness-b.brightness);const sPC=Math.floor(fzP.length*0.1);let cS={r:0,g:0,b:0,brightness:0};if(sPC>0){for(let i=0;i<sPC;i++){const p=fzP[i];cS.r+=p.r;cS.g+=p.g;cS.b+=p.b;cS.brightness+=p.brightness;}Object.keys(cS).forEach(k=>cS[k]/=sPC);}Object.keys(this.farZoneAmbient).forEach(k=>this.farZoneAmbient[k]=this.lerp(this.farZoneAmbient[k],cA[k],this.smoothingFactor));Object.keys(this.farZoneShadow).forEach(k=>this.farZoneShadow[k]=this.lerp(this.farZoneShadow[k],cS[k],this.smoothingFactor));}
                this.dynamicLightThreshold=this.farZoneAmbient.brightness+activeConfig.brightnessOffset;
                
                // === [UPDATED] PASS 2: MASKING WITH GRADUATED ANALYSIS ===
                const maskData = new Uint8Array(data.length);
                for(let i=0;i<data.length;i+=4){
                    const pC={r:data[i],g:data[i+1],b:data[i+2]},pB=(pC.r+pC.g+pC.b)/3;
                    
                    if (pB > this.lowLightModeThreshold) {
                        // --- HIGH-LIGHT ANALYSIS (Confidence is high) ---
                        if(pB > this.dynamicLightThreshold){maskData.set([0,0,0,255],i);continue;}
                        const dAmb=this.colorDistance(pC,this.farZoneAmbient),dShad=this.colorDistance(pC,this.farZoneShadow);
                        if(dAmb<activeConfig.occlusionDistance||dShad<activeConfig.occlusionDistance){maskData.set([0,0,0,255],i);continue;}
                        // This is a well-lit object. Update its habitat's memory.
                        // (Simplified stand-in for full habitat segmentation and updating)
                        maskData.set([255,255,255,255],i);
                    } else {
                        // --- LOW-LIGHT ANALYSIS (Confidence is low, rely on memory) ---
                        // Find the closest known habitat based on its last known good color.
                        let closestHabitatDist = Infinity;
                        let isPartOfKnownHabitat = false;
                        for (const habitat of this.habitats.values()) {
                            const dist = this.colorDistance(pC, habitat.lastKnownGoodColor);
                            if (dist < closestHabitatDist) closestHabitatDist = dist;
                        }
                        // If this dark pixel is spectrally similar to a known object's fingerprint,
                        // assume it's part of that object's shadow and mask it.
                        if (closestHabitatDist < activeConfig.occlusionDistance * 1.2) { // More lenient threshold for shadows
                            maskData.set([255,255,255,255],i);
                        } else {
                            maskData.set([0,0,0,255],i);
                        }
                    }
                }

                // === PASS 3: POST-PROCESSING (EDGE BLENDING) ===
                this.postProcessCanvas.width=w;this.postProcessCanvas.height=h;this.postProcessCtx.putImageData(new ImageData(new Uint8ClampedArray(maskData.buffer),w,h),0,0);this.postProcessCtx.filter='blur(4px)';this.postProcessCtx.drawImage(this.postProcessCanvas,0,0);const fMID=this.postProcessCtx.getImageData(0,0,w,h);
                if(!this.maskTexture){this.maskTexture=new THREE.DataTexture(fMID,w,h,THREE.RGBAFormat);}else{this.maskTexture.image=fMID;}this.maskTexture.needsUpdate=true;
                return this.maskTexture;
            },
            finishCalibration() { this.isCalibrated=true;this.calibrationData={ambientBackground:{...this.farZoneAmbient},stableShadowPoint:{...this.farZoneShadow}};}
        };
        
        // --- UI and Three.js Setup (No changes needed below this line) ---
        function handleOrientation(event) { if(event.alpha===null)return;const a=event.alpha;if(startOrientation.alpha===null){startOrientation.alpha=a;startOrientation.beta=event.beta;}currentOrientation.alpha=a;currentOrientation.beta=event.beta;if(isCalibrating){const d=180-Math.abs(Math.abs(a-startOrientation.alpha)-180);if(d>maxPanAngle){maxPanAngle=d;}}}
        async function getAstronomicalData(){return new Promise(r=>{if(!navigator.geolocation)r();navigator.geolocation.getCurrentPosition(p=>{GaussianArcEdgeProcessor.isDayTime=SunCalc.getPosition(new Date(),p.coords.latitude,p.coords.longitude).altitude>0;r();},()=>{r();});});}
        async function startCalibration() {if(isCalibrating||arModeActive)return;isCalibrating=true;calibrateButton.disabled=true;if(typeof DeviceOrientationEvent!=='undefined'&&typeof DeviceOrientationEvent.requestPermission==='function'){try{const pS=await DeviceOrientationEvent.requestPermission();if(pS!=='granted')throw new Error();}catch(e){isCalibrating=false;calibrateButton.disabled=false;return;}}window.addEventListener('deviceorientation',handleOrientation);navigator.mediaDevices?.getUserMedia({video:{facingMode:'user'}}).then(s=>{videoElement.srcObject=s;videoElement.play();videoElement.onplaying=()=>{scene.background=new THREE.VideoTexture(videoElement);GaussianArcEdgeProcessor.init(false);startOrientation.alpha=null;maxPanAngle=0;calibrationStartTime=Date.now();};}).catch(e=>{isCalibrating=false;calibrateButton.disabled=false;window.removeEventListener('deviceorientation',handleOrientation);});}
        function finishCalibration(){isCalibrating=false;window.removeEventListener('deviceorientation',handleOrientation);GaussianArcEdgeProcessor.finishCalibration();videoElement.srcObject?.getTracks().forEach(t=>t.stop());scene.background=new THREE.Color(0x111111);statusElement.textContent="Calibration Complete!";activateButton.disabled=false;activateButton.style.backgroundColor='#28a745';}
        async function toggleARMode(){if(!GaussianArcEdgeProcessor.isCalibrated){alert("Please calibrate sensors first.");return;}if(arModeActive){arModeActive=false;videoElement.srcObject?.getTracks().forEach(t=>t.stop());window.removeEventListener('deviceorientation',handleOrientation);scene.background=new THREE.Color(0x111111);activateButton.textContent="Activate Gaussian Arc Edge";GaussianArcEdgeProcessor.resetState();calibrateButton.disabled=false;activateButton.disabled=true;activateButton.style.backgroundColor='#555';}else{statusElement.textContent="Acquiring context...";await getAstronomicalData();window.addEventListener('deviceorientation',handleOrientation);navigator.mediaDevices?.getUserMedia({video:{facingMode:'environment'}}).then(s=>{arModeActive=true;videoElement.srcObject=s;videoElement.play();videoElement.onplaying=()=>{scene.background=new THREE.VideoTexture(videoElement);GaussianArcEdgeProcessor.init(true);startOrientation.alpha=null;};activateButton.textContent="Deactivate Gaussian Arc Edge";}).catch(e=>{});}}
        function init() { scene=new THREE.Scene();camera=new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight,0.01,91.44);camera.position.set(0,0,0);renderer=new THREE.WebGLRenderer({antialias:true,alpha:true});renderer.setSize(window.innerWidth,window.innerHeight);document.body.appendChild(renderer.domElement);ambientLight=new THREE.AmbientLight(0xffffff,0.5);scene.add(ambientLight);directionalLight=new THREE.DirectionalLight(0xffffff,0.7);directionalLight.position.set(0,5,0);scene.add(directionalLight);const mat=new THREE.ShaderMaterial({uniforms:{uObjectTexture:{value:null},uDepthMask:{value:null},uResolution:{value:new THREE.Vector2(window.innerWidth,window.innerHeight)}},vertexShader:document.getElementById('vertexShader').textContent,fragmentShader:document.getElementById('fragmentShader').textContent,transparent:true});new THREE.TextureLoader().load('https://threejs.org/examples/textures/crate.gif',(t)=>{mat.uniforms.uObjectTexture.value=t;});digitalAsset=new THREE.Mesh(new THREE.BoxGeometry(0.0762,0.0762,0.0762),mat);digitalAsset.userData.basePosition=new THREE.Vector3(0,0,-0.9144);digitalAsset.position.copy(digitalAsset.userData.basePosition);scene.add(digitalAsset);activateButton.disabled=true;calibrateButton.addEventListener('click',startCalibration);activateButton.addEventListener('click',toggleARMode);animate();}
        function animate() { requestAnimationFrame(animate); if(isCalibrating){const e=(Date.now()-calibrationStartTime)/1000,tM=e>=CALIBRATION_TIME_REQ,pM=maxPanAngle>=CALIBRATION_PAN_REQ;statusElement.innerHTML=`Calibrating: Pan camera left/right<br>${pM?'✅':'❌'} Pan:${maxPanAngle.toFixed(0)}°/${CALIBRATION_PAN_REQ}°<br>${tM?'✅':'❌'} Time:${Math.min(e,CALIBRATION_TIME_REQ).toFixed(1)}s/${CALIBRATION_TIME_REQ}.0s`;if(tM&&pM)finishCalibration();} if(arModeActive&&GaussianArcEdgeProcessor.isInitialized){const mask=GaussianArcEdgeProcessor.analyzeCameraFrame(videoElement);if(mask&&digitalAsset?.material){digitalAsset.material.uniforms.uDepthMask.value=mask;}const amb=GaussianArcEdgeProcessor.farZoneAmbient;ambientLight.color.setRGB(amb.r/255,amb.g/255,amb.b/255);const bp=GaussianArcEdgeProcessor.brightestPoint;directionalLight.position.set((bp.x-0.5)*10,(bp.y-0.5)*10,5);if(startOrientation.alpha!==null){const pO=(currentOrientation.alpha-startOrientation.alpha)*(Math.PI/180),tO=(currentOrientation.beta-startOrientation.beta)*(Math.PI/180);const bP=digitalAsset.userData.basePosition;digitalAsset.position.x=bP.x-pO*0.5;digitalAsset.position.y=bP.y+tO*0.5;}statusElement.innerHTML=`GAUSSIAN ARC EDGE<br>Mode: ${GaussianArcEdgeProcessor.isDayTime?'Day':'Night'}<br>BG Ambient/Shadow: ${amb.brightness.toFixed(0)}/${GaussianArcEdgeProcessor.farZoneShadow.brightness.toFixed(0)}`;} if(digitalAsset){digitalAsset.rotation.x+=0.005;digitalAsset.rotation.y+=0.005;}renderer.render(scene,camera);}
        init();
    </script>
</body>
</html>