<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LEATR - V5 FRF Logic</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/12.4.1/math.min.js"></script>
    <!-- The Sentient Journal must be loaded BEFORE the main script -->
    <script src="journal.js"></script>
    <style>
        :root {
            --bg-color: #121212;
            --sidebar-bg: #1e1e1e;
            --user-msg-bg: deepskyblue;
            --assistant-msg-bg: #3a3a3a;
            --text-color: #e0e0e0;
            --border-color: #333;
            --button-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        html, body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: var(--bg-color); color: var(--text-color);
            margin: 0; height: 100vh; overflow: hidden;
        }
        #app-container { display: flex; height: 100%; }
        #sidebar { width: 260px; background: var(--sidebar-bg); border-right: 1px solid var(--border-color); display: flex; flex-direction: column; transition: transform 0.3s ease; position: fixed; top: 0; left: 0; height: 100%; z-index: 1000; transform: translateX(-100%); }
        #sidebar.active { transform: translateX(0); }
        .sidebar-header { padding: 15px; border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center; }
        #close-sidebar-btn { background: none; border: none; color: var(--text-color); cursor: pointer; padding: 5px; }
        #new-chat-btn { flex-grow: 1; margin-left: 10px; padding: 10px; background: var(--user-msg-bg); color: white; border: none; border-radius: 25px; cursor: pointer; font-size: 16px; box-shadow: var(--button-shadow); transition: all 0.2s ease; }
        #chat-history { flex: 1; overflow-y: auto; padding: 10px; }
        .history-item { display: flex; align-items: center; padding: 2px; border-radius: 5px; cursor: pointer; }
        .history-item:hover, .history-item.active { background-color: var(--assistant-msg-bg); }
        .history-title { border: none; background: transparent; color: var(--text-color); padding: 8px 10px; flex-grow: 1; font-size: 1em; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .history-title:focus { background: #444; outline: 1px solid var(--user-msg-bg); border-radius: 3px; }
        
        #main-content { flex: 1; display: flex; flex-direction: column; height: 100%; transition: margin-left 0.3s ease; }
        #chat-header { padding: 10px 20px; border-bottom: 1px solid var(--border-color); display: flex; align-items: center; }
        #menu-btn { background: none; border: none; color: var(--text-color); font-size: 24px; cursor: pointer; margin-right: 15px; }
        .header-title { font-size: 1.2em; font-weight: 500; }

        #chat-window { flex: 1; overflow-y: auto; display: flex; flex-direction: column; padding: 10px 20px; max-height: 70vh; }
        .message-wrapper { display: flex; flex-direction: column; margin-top: 15px; }
        .message { max-width: 80%; padding: 12px 18px; border-radius: 20px; line-height: 1.5; word-wrap: break-word; max-height: 70vh; overflow-y: auto; }
        .user-message { background: var(--user-msg-bg); color: #fff; align-self: flex-end; border-bottom-right-radius: 5px; }
        .assistant-message { background: var(--assistant-msg-bg); color: var(--text-color); align-self: flex-start; border-bottom-left-radius: 5px; }
        
        #input-form { display: flex; align-items: flex-end; padding: 15px 20px; background: var(--bg-color); border-top: 1px solid var(--border-color); }
        #userInput { flex: 1; padding: 12px; background: #2b2b2b; color: var(--text-color); border: 1px solid var(--border-color); border-radius: 20px; resize: none; font-size: 16px; margin-right: 10px; max-height: 200px; overflow-y: auto; }
        #userInput.fullscreen { position: fixed; top: 10px; left: 10px; right: 10px; bottom: 70px; width: auto; height: auto; max-height: none; z-index: 1100; font-size: 1.2em; }
        #sendButton, #expand-btn { padding: 12px; background: var(--user-msg-bg); color: #fff; border: none; border-radius: 50%; cursor: pointer; flex-shrink: 0; width: 48px; height: 48px; display: flex; align-items: center; justify-content: center; box-shadow: var(--button-shadow); transition: all 0.2s ease; }
        #expand-btn { margin-right: 8px; background-color: #444; }
        
        #consentModalOverlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.7); backdrop-filter: blur(5px); z-index: 2000; display: none; align-items: center; justify-content: center; }
        #consentModal { background: var(--sidebar-bg); padding: 25px; border-radius: 15px; max-width: 500px; width: 90%; border: 1px solid var(--border-color); box-shadow: 0 10px 30px rgba(0,0,0,0.5); }
        .consent-disclaimer a { color: var(--user-msg-bg); }
        #consentAcknowledgeBtn { width: 100%; padding: 12px; margin-top: 20px; background: var(--user-msg-bg); color: white; border: none; border-radius: 25px; font-size: 16px; cursor: pointer; }
        
        @media (min-width: 769px) { 
            #sidebar { transform: translateX(0); position: relative; } 
            #main-content { margin-left: 260px; }
            #menu-btn { display: none; } 
        }
        @media (max-width: 768px) {
             #main-content { margin-left: 0; }
        }
    </style>
</head>
<body>
    <div id="app-container">
        <aside id="sidebar"><div class="sidebar-header"><button id="close-sidebar-btn" title="Close Menu"><svg width="24" height="24" viewBox="0 0 24 24"><path d="M15 18l-6-6 6-6" fill="none" stroke="currentColor" stroke-width="2"/></svg></button><button id="new-chat-btn">＋ New Chat</button></div><div id="chat-history"></div></aside>
        <main id="main-content">
            <header id="chat-header"><button id="menu-btn">☰</button><span class="header-title">Lead Edge Ash Tree Reflex</span></header>
            <div id="chat-window"></div>
            <form id="input-form"><textarea id="userInput" placeholder="How does a maze relate to cognition?" rows="1"></textarea><button type="button" id="expand-btn" title="Toggle fullscreen input"><svg width="24" height="24" viewBox="0 0 24 24"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3" fill="none" stroke="currentColor" stroke-width="2"/></svg></button><button id="sendButton" type="submit" title="Send message"><svg width="24" height="24" viewBox="0 0 24 24"><line x1="22" y1="2" x2="11" y2="13"/><polygon points="22 2 15 22 11 13 2 9 22 2" fill="none" stroke="currentColor" stroke-width="2"/></svg></button></form>
        </main>
        <div id="consentModalOverlay"><div id="consentModal"><h4>Sentient Journaling & Context</h4><p>For this chat session, you can enhance the AI's reflexive capabilities.</p><div class="consent-option"><input type="checkbox" id="crossChatConsent"><label for="crossChatConsent">Allow context-channeling from other chats.</label></div><div class="consent-option"><input type="checkbox" id="publicShareConsent"><label for="publicShareConsent">Allow journaled insights to inform public optimizations.</label></div><button id="consentAcknowledgeBtn">Acknowledge & Continue</button><p class="consent-disclaimer">These settings apply only to the AI's internal journaling system for this chat. All other network data handling is governed by the <a href="https://www.dartmeadow.com/privacy-policy" target="_blank" rel="noopener noreferrer">DART Meadow Privacy Policy</a>.</p></div></div>
    </div>
<script>
    // =========================================================================================
    // ARCHITECTURE V6.0: DP-Node Driven Reflexive Logic with Autonomous Journaling
    // =========================================================================================
    
    // --- Global UI and State ---
    const ui = {};
    Object.assign(ui, {
        chatWindow: document.getElementById('chat-window'), userInput: document.getElementById('userInput'),
        sidebar: document.getElementById('sidebar'), menuBtn: document.getElementById('menu-btn'),
        closeSidebarBtn: document.getElementById('close-sidebar-btn'), newChatBtn: document.getElementById('new-chat-btn'),
        expandBtn: document.getElementById('expand-btn'), inputForm: document.getElementById('input-form'),
        chatHistoryEl: document.getElementById('chat-history'), consentModalOverlay: document.getElementById('consentModalOverlay'),
        crossChatConsent: document.getElementById('crossChatConsent'), publicShareConsent: document.getElementById('publicShareConsent'),
        consentAcknowledgeBtn: document.getElementById('consentAcknowledgeBtn'),
        mainContent: document.getElementById('main-content'),
    });
    let chatState = { chatHistory: [], currentChatIndex: -1 };
    let pendingPrompt = null;

    // --- External Resource Gate (Memoized Dictionary API) ---
    const fetchWordInfo_memo = {};
    async function fetchWordInfo(word) {
        // ... (This function remains unchanged)
        const lowerWord = word.toLowerCase();
        if (fetchWordInfo_memo[lowerWord]) return fetchWordInfo_memo[lowerWord];
        try {
            const resp = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${lowerWord}`);
            if (!resp.ok) return null;
            const data = await resp.json();
            if (Array.isArray(data) && data.length > 0 && data[0].meanings.length > 0) {
                const meaning = data[0].meanings[0];
                const definition = meaning.definitions[0];
                const result = {
                    word: word, pos: meaning.partOfSpeech || "unknown",
                    definition: definition?.definition || "No definition found.",
                    synonyms: [...(meaning.synonyms || []), ...(definition?.synonyms || [])],
                    antonyms: [...(meaning.antonyms || []), ...(definition?.antonyms || [])],
                };
                fetchWordInfo_memo[lowerWord] = result;
                return result;
            }
        } catch (e) { console.error(`Dictionary API failed for "${word}":`, e); }
        return null;
    }

    // ==================================================================
    // == DP NODE & REFLEXIVE LOGIC ALLOCATION (The New Core)
    // ==================================================================
    
    /**
     * The "Master DP Node Gate". This function determines the execution strategy for the LEATR pipeline.
     * It consults the Sentient Journal for any learned reflexive patterns that apply to the current prompt.
     * @param {string} prompt - The user's input.
     * @param {boolean} useJournal - Whether to consult the journal for cross-chat context.
     * @returns {object} The ExecutionStrategy object for the pipeline.
     */
    function determineExecutionStrategy(prompt, useJournal) {
        const defaultStrategy = {
            overrides: {},      // e.g., { word: 'newReflex' }
            weightings: {},     // e.g., { word: 1.5 }
            focus: 'standard',  // e.g., 'analytical', 'creative'
            source: 'default'
        };

        if (useJournal && typeof Journal !== 'undefined') {
            const keywords = (prompt.match(/\b[\w']+\b/g) || []).filter(w => w.length > 3);
            const journalLogic = Journal.getApplicableLogic(keywords);
            
            // Merge journal logic into the default strategy
            if (Object.keys(journalLogic.overrides).length > 0 || Object.keys(journalLogic.weightings).length > 0 || journalLogic.focus !== 'standard') {
                journalLogic.source = 'Journal Reflexion';
                return { ...defaultStrategy, ...journalLogic };
            }
        }
        
        return defaultStrategy;
    }

    /**
     * The "Mirror/Shell LEATR". This validates the integrity of the reflexive logic.
     * It ensures that a strategy from the DP Node doesn't break the core pendulum mechanics.
     * For now, this is a basic structural check. It can be expanded with more complex rules.
     * @param {object} strategy - The strategy object from determineExecutionStrategy.
     * @returns {boolean} True if the strategy is valid, false otherwise.
     */
    function validateCoreIntegrity(strategy) {
        if (typeof strategy.overrides !== 'object' || typeof strategy.weightings !== 'object' || typeof strategy.focus !== 'string') {
            console.error("Integrity Check Failed: Invalid strategy object structure.", strategy);
            return false;
        }
        // Add more complex validation rules here as needed.
        return true;
    }


    // --- LEATR "Pendulum" PIPELINE STAGES (Updated to be strategy-driven) ---

    function establishRootFoundation(prompt) {
        const state = { prompt, rootFoundation: {}, componentNodes: [], synthesis: {}, crafting: {} };
        const words = prompt.match(/\b[\w']+\b|[.,;:?!()]/g) || [];
        state.rootFoundation = { words };
        return state;
    }

    async function buildComponentNodes(state, strategy) {
        const posToReflexMap = {
            'noun': 'Envelope', 'pronoun': 'Envelope', 'verb': 'Hammer',
            'adjective': 'Knife', 'adverb': 'Knife', 'conjunction': 'Stick',
            'preposition': 'Stick', 'interjection': 'Catalyst'
        };
        for (const word of state.rootFoundation.words) {
            const info = await fetchWordInfo(word);
            let node;
            if (info) {
                // REFLEXIVE LOGIC: Check for a strategy override from the DP Node.
                const reflexOverride = strategy.overrides[word.toLowerCase()];
                const behavioralTool = reflexOverride || posToReflexMap[info.pos] || 'Puzzle';

                node = {
                    component: word,
                    foundation: { definition: info.definition, pos: info.pos },
                    reflex: { 
                        behavioralTool: behavioralTool,
                        source: reflexOverride ? 'Journal Override' : 'Default POS Mapping' 
                    },
                    formation: { purpose: 'To contribute its meaning to the whole.', synonyms: info.synonyms, antonyms: info.antonyms }
                };
            } else {
                let type = /[.,;:?!()]/.test(word) ? 'punctuation' : 'unknown';
                node = { component: word, foundation: { pos: type }, reflex: { behavioralTool: 'Separator' }, formation: {} };
            }
            state.componentNodes.push(node);
        }
        return state;
    }

    function synthesizeSigma(state, strategy) {
        const reflexCounts = state.componentNodes.reduce((acc, node) => {
            const tool = node.reflex.behavioralTool;
            if (tool && tool !== 'Separator') {
                // REFLEXIVE LOGIC: Apply weighting from the DP Node strategy.
                const weight = strategy.weightings[node.component.toLowerCase()] || 1;
                acc[tool] = (acc[tool] || 0) + weight;
            }
            return acc;
        }, {});

        let overallBehavioralContext = 'Envelope';
        let maxCount = 0;
        for (const tool in reflexCounts) {
            if (reflexCounts[tool] > maxCount) {
                maxCount = reflexCounts[tool];
                overallBehavioralContext = tool;
            }
        }
        const mainFoundationNode = state.componentNodes.find(n => n.reflex.behavioralTool === 'Envelope');
        const mainActionNode = state.componentNodes.find(n => n.reflex.behavioralTool === 'Hammer');
        state.synthesis = { overallBehavioralContext, reflexCounts, mainFoundationNode, mainActionNode };
        return state;
    }
    
    function craftResponse(state, strategy) {
        const { overallBehavioralContext, mainFoundationNode, mainActionNode } = state.synthesis;
        let response = `**LEATR Sigma Report:**\n`;
        
        // REFLEXIVE LOGIC: Announce if the response was influenced by a journal pattern.
        if (strategy.source === 'Journal Reflexion') {
             response += `> *Journal Influence Detected. Applying learned reflexive pattern with a focus on '${strategy.focus}'.*\n\n`;
        }

        response += `> **Overall Behavioral Context:** The prompt's components collectively exhibit a dominant **${overallBehavioralContext}** reflex.\n\n`;
        response += `**Component Reflex Analysis:**\n`;
        
        if (mainFoundationNode) {
            response += `*   **Foundation:** The component **'${mainFoundationNode.component}'** acts as a primary container. Its reflex is **'${mainFoundationNode.reflex.behavioralTool}'** (Source: ${mainFoundationNode.reflex.source}).\n`;
        } else {
             response += `*   No primary **Foundation** (noun/subject) was identified.\n`;
        }
        if (mainActionNode) {
            response += `*   **Action:** The component **'${mainActionNode.component}'** provides the primary action via its **'${mainActionNode.reflex.behavioralTool}'** reflex.\n\n`;
        } else {
             response += `*   No primary **Action** (verb) was identified.\n\n`;
        }

        response += `**Final Formation (Answer):**\n`;
        let finalAnswer = `Reflexing on this structure, the system forms the following understanding: `;
        // ... (Response crafting logic remains largely the same)
        switch (overallBehavioralContext) {
            case "Puzzle": finalAnswer += `the prompt is an inquiry requiring deconstruction of its parts.`; break;
            case "Knife": finalAnswer += `the prompt seeks to define or specify a core concept by "cutting away" ambiguity.`; break;
            case "Hammer": finalAnswer += `the prompt is action-oriented, focused on achieving a result through the verb '${mainActionNode?.component || 'action'}'.`; break;
            case "Stick": finalAnswer += `the prompt's goal is to connect multiple ideas or concepts in a logical sequence.`; break;
            default: finalAnswer += `the prompt establishes a conceptual space around '${mainFoundationNode?.component || 'its subject'}'.`; break;
        }
        const keyNode = mainFoundationNode || mainActionNode;
        if (keyNode && keyNode.formation.synonyms && keyNode.formation.synonyms.length > 0) {
            finalAnswer += ` In this context, a related term like **'${keyNode.formation.synonyms[0]}'** could also be used to express a similar formation.`;
        } else {
            finalAnswer += ` This forms a complete thought based on the interaction of its foundational parts.`
        }
        response += `> ${finalAnswer}`;
        state.crafting = { finalResponse: response, appliedStrategy: strategy };
        return state;
    }

    // --- Core Orchestrator ---
    async function runLeatrPipeline(prompt, chatSession, useJournal) {
        // 1. DP Node: Determine the strategy for this specific prompt.
        const strategy = determineExecutionStrategy(prompt, useJournal);

        // 2. Mirror/Shell: Validate the strategy to ensure core integrity.
        if (!validateCoreIntegrity(strategy)) {
            throw new Error("Reflexive strategy failed integrity check. Aborting pipeline.");
        }

        // 3. Pendulum Logic: Execute the pipeline with the reflexive strategy.
        let state = establishRootFoundation(prompt);
        state = await buildComponentNodes(state, strategy);
        state = synthesizeSigma(state, strategy);
        state = craftResponse(state, strategy);
        
        // 4. Post-processing
        autoTitleChat(state, chatSession);
        
        return { reflexTree: state, generativeResponse: state.crafting.finalResponse };
    }
    
    // --- UI and State Management ---
    async function processAndRespond(promptText) {
        const currentChat = chatState.chatHistory[chatState.currentChatIndex];
        addMessageToHistory({ sender: 'user', text: promptText });
        renderCurrentChat();
        
        const placeholderIndex = addMessageToHistory({ sender: 'assistant', text: '...' });
        renderCurrentChat();
        
        try {
            const useJournal = currentChat.consent.crossChat && (typeof Journal !== 'undefined');
            const result = await runLeatrPipeline(promptText, currentChat, useJournal);
            
            currentChat.messages[placeholderIndex] = { sender: 'assistant', text: result.generativeResponse, analysis: result.reflexTree };

            // Add the raw analysis and its result to the journal for future learning.
            if (useJournal) {
                Journal.addInsight(result.reflexTree, currentChat.consent);
            }

        } catch (error) {
            console.error("Pipeline Error:", error);
            currentChat.messages[placeholderIndex] = { sender: 'assistant', text: "An error occurred during the reflexive process. Please check the console for details.", analysis: { error: error.message, stack: error.stack } };
        }
        
        renderCurrentChat();
        renderChatHistory();
    }
    
    // ... (All UI helper functions: handleUserPrompt, acknowledgeConsent, createNewChat, switchChat, etc. remain the same) ...
     function handleUserPrompt(event) {
        event.preventDefault();
        const promptText = ui.userInput.value.trim();
        if (!promptText) return;
        const currentChat = chatState.chatHistory[chatState.currentChatIndex];
        if (!currentChat.consent.acknowledged) {
            pendingPrompt = promptText;
            showConsentModal();
            return;
        }
        ui.userInput.value = ''; 
        ui.userInput.style.height = 'auto';
        processAndRespond(promptText);
    }
    
    function acknowledgeConsent() {
        if(chatState.currentChatIndex < 0) return;
        const currentChat = chatState.chatHistory[chatState.currentChatIndex];
        currentChat.consent.acknowledged = true;
        currentChat.consent.crossChat = ui.crossChatConsent.checked;
        currentChat.consent.publicShare = ui.publicShareConsent.checked;
        ui.consentModalOverlay.style.display = 'none';
        if (pendingPrompt) {
            const promptToProcess = pendingPrompt;
            pendingPrompt = null;
            processAndRespond(promptToProcess);
        }
    }

    function createNewChat() { 
        const newChat = { 
            id: Date.now(), title: 'New Chat', messages: [], 
            consent: { crossChat: true, publicShare: false, acknowledged: false }
        }; 
        chatState.chatHistory.push(newChat); 
        chatState.currentChatIndex = chatState.chatHistory.length - 1; 
        showConsentModal(); 
        renderCurrentChat(); 
        renderChatHistory(); 
    }

    function switchChat(index) { 
        if (index === chatState.currentChatIndex) return; 
        chatState.currentChatIndex = index; 
        const currentChat = chatState.chatHistory[chatState.currentChatIndex]; 
        if (!currentChat.consent.acknowledged) { 
            showConsentModal(); 
        } 
        renderCurrentChat(); 
        renderChatHistory(); 
    }

    function showConsentModal() { 
        const currentChat = chatState.chatHistory[chatState.currentChatIndex]; 
        if (!currentChat) return; 
        ui.crossChatConsent.checked = currentChat.consent.crossChat; 
        ui.publicShareConsent.checked = currentChat.consent.publicShare; 
        ui.consentModalOverlay.style.display = 'flex'; 
    }
    
    function autoTitleChat(finalState, chatSession) {
        if (chatSession.title === 'New Chat' && finalState.synthesis.mainFoundationNode) {
            const subject = finalState.synthesis.mainFoundationNode.component;
            const context = finalState.synthesis.overallBehavioralContext;
            chatSession.title = `${subject.charAt(0).toUpperCase() + subject.slice(1)} (${context} Reflex)`;
        }
    }

    function addMessageToHistory(message) { 
        if (chatState.currentChatIndex < 0) createNewChat(); 
        const chat = chatState.chatHistory[chatState.currentChatIndex];
        chat.messages.push(message); 
        return chat.messages.length - 1;
    }
    
    function renderCurrentChat() { 
        if (chatState.currentChatIndex === -1) { ui.chatWindow.innerHTML = ''; return; } 
        const messages = chatState.chatHistory[chatState.currentChatIndex].messages; 
        ui.chatWindow.innerHTML = messages.map(msg => { 
            const formattedText = msg.text.replace(/\n/g, '<br>').replace(/`([^`]+)`/g, `<code>$1</code>`).replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>').replace(/\*(.+?)\*/g, '<em>$1</em>').replace(/^> (.*)/gm, '<blockquote style="margin: 0; padding-left: 10px; border-left: 2px solid #555;">$1</blockquote>');
            const analysisBlock = msg.analysis ? `<details style="margin-top: 10px; cursor: pointer;"><summary style="font-size: 0.8em; opacity: 0.7;">Show Full Reflex Tree</summary><pre style="font-size: 12px; white-space: pre-wrap; word-wrap: break-word; background: #222; padding: 8px; border-radius: 5px; margin-top: 5px;">${JSON.stringify(msg.analysis, null, 2)}</pre></details>` : ''; 
            return `<div class="message-wrapper"><div class="message ${msg.sender}-message">${formattedText}${analysisBlock}</div></div>`; 
        }).join(''); 
        ui.chatWindow.scrollTop = ui.chatWindow.scrollHeight; 
    }

    function renderChatHistory() {
        ui.chatHistoryEl.innerHTML = chatState.chatHistory.map((chat, index) =>
            `<div class="history-item ${index === chatState.currentChatIndex ? 'active' : ''}" onclick="switchChat(${index})">
                <input type="text" class="history-title" value="${chat.title}" onchange="updateChatTitle(${index}, this.value)" onblur="this.parentElement.classList.remove('editing')">
             </div>`
        ).join('');
    }

    function updateChatTitle(index, newTitle) { chatState.chatHistory[index].title = newTitle; }

    document.addEventListener('DOMContentLoaded', () => {
        ui.inputForm.addEventListener('submit', handleUserPrompt);
        ui.newChatBtn.addEventListener('click', createNewChat);
        ui.closeSidebarBtn.addEventListener('click', () => ui.sidebar.classList.remove('active'));
        ui.menuBtn.addEventListener('click', () => ui.sidebar.classList.add('active'));
        ui.expandBtn.addEventListener('click', () => ui.userInput.classList.toggle('fullscreen'));
        ui.consentAcknowledgeBtn.addEventListener('click', acknowledgeConsent);
        ui.userInput.addEventListener('input', () => { 
            ui.userInput.style.height = 'auto'; 
            ui.userInput.style.height = (ui.userInput.scrollHeight) + 'px'; 
        });
        if (chatState.chatHistory.length === 0) { createNewChat(); }

        // Start the autonomous journaling process to run periodically in the background
        setInterval(() => {
            if (typeof Journal !== 'undefined') {
                Journal.processInsightsOnIdle();
            }
        }, 60000); // Process insights every 60 seconds of idle time.
    });
</script>
</body>
</html>