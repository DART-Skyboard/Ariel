<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Autumn | Lead Edge Ash Tree Reflex</title>
  <style>
    body { margin:0; font-family:sans-serif; background:#f0f0f0; }
    .container { display:flex; height:100vh; }
    .sidebar { width:200px; background:#222; color:#ddd; padding:16px; }
    .chat-area { flex:1; border-left:1px solid #ccc; border-right:1px solid #ccc; display:flex; flex-direction:column; }
    .chat-header { padding:16px; font-size:1.2em; border-bottom:1px solid #ccc; }
    .chat-content { flex:1; padding:16px; }
    .chat-input { padding:16px; background:#fff; border-top:1px solid #ccc; }
    .chat-input textarea { width:100%; height:80px; padding:8px; border:1px solid #ccc; border-radius:4px; }
    .chat-input .controls { margin-top:8px; }
    .chat-input button { margin-right:8px; padding:8px 12px; border:none; border-radius:4px; background:#eee; cursor:pointer; }
    .chat-input button:hover { background:#ddd; }

    .control-panel { width:340px; padding:16px; display:flex; flex-direction:column; }
    .toolbar { display:flex; flex-wrap:wrap; gap:8px; margin-bottom:12px; }
    .toolbar .draggable {
      width:50px; height:50px;
      border:3px solid #09f; border-radius:6px;
      display:flex; align-items:center; justify-content:center;
      font-size:1.2em; font-weight:bold; color:#09f;
      background:#fff; cursor:grab;
    }

    /* Canvas: icon row + workspace */
    .circuit-container { flex:1; background:#fff; border:1px solid #ccc; border-radius:8px; display:flex; flex-direction:column; overflow:hidden; }
    .canvas-controls {
      display:flex; justify-content:space-around;
      background:#fafafa; border-bottom:1px solid #ddd;
      padding:4px 0;
    }
    .canvas-controls button {
      width:32px; height:32px;
      background:transparent; border:none; border-radius:4px;
      font-size:18px; color:#444; cursor:pointer;
      display:flex; align-items:center; justify-content:center;
      transition: background .2s, color .2s;
    }
    .canvas-controls button.active {
      background:#09f; color:#fff;
    }
    .canvas-scroll { flex:1; overflow:auto; position:relative; }

    .panzoom {
      position:relative;
      width:2000px; height:2000px;
      transform-origin:0 0;
      transform:scale(1);
    }
    .panzoom svg {
      position:absolute; top:0; left:0;
      width:100%; height:100%;
      pointer-events:none;
    }
    .node {
      position:absolute;
      width:50px; height:50px;
      border:3px solid #09f; border-radius:6px;
      display:flex; align-items:center; justify-content:center;
      font-size:1.2em; font-weight:bold; color:#09f;
      background:#fff; cursor:pointer;
      user-select:none;
    }
    svg polyline {
      stroke:#000; stroke-width:4; fill:none; cursor:pointer;
    }

    #home{
      background-color: deepskyblue;
      color: white;
      border: none;
      padding: 6px 20px;
      border-radius: 5px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="sidebar">
        <h2>Autumn</h2>
        <p>Ash Canvas</p><br>
        <button
  id="home"
  style="display:block; width:100%; margin:8px 0;"
  onclick="location.href='https://skyboard.space'"
>
Home
</button>
</div>
        <!-- ASH Canvas -->


    <div class="chat-area">
      <div class="chat-header">What's on your mind today?</div>
      <div class="chat-content">
       
        <p style="color:#666; margin-top:16px;">Ask anything‚Ä¶</p>
      </div>
      <div class="chat-input">
        <textarea placeholder="Type your message‚Ä¶"></textarea>
        <div class="controls">
          <button>Search</button>
          <button>Arc Edge</button>
          <button>Create Media</button>
        </div>
      </div>
    </div>

    <div class="control-panel">
      <!-- draggable nodes -->
      <div class="toolbar">
        <div class="draggable" draggable="true" data-type="M">M</div>
        <div class="draggable" draggable="true" data-type="P">P</div>
        <div class="draggable" draggable="true" data-type="E">E</div>
        <div class="draggable" draggable="true" data-type="H">H</div>
        <div class="draggable" draggable="true" data-type="S">S</div>
        <div class="draggable" draggable="true" data-type="K">K</div>
        <div class="draggable" draggable="true" data-type="R">R</div>
      </div>

      <!-- icon toolbar -->
      <div class="circuit-container">
        <div class="canvas-controls">
          <button id="linkBtn"    title="Link Mode üîó">üîó</button>
          <button id="unlinkBtn"  title="Unlink Mode ‚ùå">‚ùå</button>
          <button id="undoBtn"    title="Undo ‚Ü∂">‚Ü∂</button>
          <button id="redoBtn"    title="Redo ‚Ü∑">‚Ü∑</button>
          <button id="zoomIn"     title="Zoom In ‚ûï">‚ûï</button>
          <button id="zoomOut"    title="Zoom Out ‚ûñ">‚ûñ</button>
          <button id="clearCanvas" title="Clear üóëÔ∏è">üóëÔ∏è</button>
        </div>
        <div class="canvas-scroll">
          <div class="panzoom">
            <svg xmlns="http://www.w3.org/2000/svg">
              <defs>
                <marker id="arrowhead" markerWidth="10" markerHeight="7" 
                        refX="8" refY="3.5" orient="auto" fill="#000">
                  <polygon points="0 0, 10 3.5, 0 7" />
                </marker>
              </defs>
            </svg>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
  (function(){
    const draggables = document.querySelectorAll('.toolbar .draggable');
    const linkBtn    = document.getElementById('linkBtn');
    const unlinkBtn  = document.getElementById('unlinkBtn');
    const zoomInBtn  = document.getElementById('zoomIn');
    const zoomOutBtn = document.getElementById('zoomOut');
    const clearBtn   = document.getElementById('clearCanvas');
    const undoBtn    = document.getElementById('undoBtn');
    const redoBtn    = document.getElementById('redoBtn');
    const container  = document.querySelector('.canvas-scroll');
    const panzoom    = document.querySelector('.panzoom');
    const svg        = panzoom.querySelector('svg');

    const gridSize   = 60;
    let drawMode     = false, unlinkMode = false, startNode = null;
    let nodeCounter  = 0, scale = 1; // Ensure nodeCounter is initialized here
    const undoStack  = [], redoStack = [];

    function updateButtons(){
      undoBtn.disabled = !undoStack.length;
      redoBtn.disabled = !redoStack.length;
    }
    function pushAction(act){
      undoStack.push(act);
      redoStack.length = 0;
      updateButtons();
    }

    // Link/Unlink toggle with active highlight
    linkBtn.onclick = ()=>{
      drawMode = !drawMode;
      if(drawMode && unlinkMode){ unlinkMode=false; unlinkBtn.classList.remove('active'); }
      linkBtn.classList.toggle('active', drawMode);
      if(!drawMode && startNode){ startNode.classList.remove('selected'); startNode=null; }
    };
    unlinkBtn.onclick = ()=>{
      unlinkMode = !unlinkMode;
      if(unlinkMode && drawMode){ drawMode=false; linkBtn.classList.remove('active'); }
      unlinkBtn.classList.toggle('active', unlinkMode);
    };

    // Zoom
    zoomInBtn.onclick  = ()=>{ scale=Math.min(scale+0.2,3); panzoom.style.transform=`scale(${scale})`; };
    zoomOutBtn.onclick = ()=>{ scale=Math.max(scale-0.2,0.4); panzoom.style.transform=`scale(${scale})`; };

    // Clear
    clearBtn.onclick = ()=>{
      panzoom.querySelectorAll('.node').forEach(n=>n.remove());
      Array.from(svg.children).forEach(l=> { // Clear only polylines, keep defs
          if (l.tagName.toLowerCase() === 'polyline') l.remove();
      });
      startNode=null; nodeCounter=0; // Reset nodeCounter on clear
      undoStack.length=redoStack.length=0;
      updateButtons();
    };

    // Undo/Redo
    undoBtn.onclick = ()=>{
      const act=undoStack.pop(); if(!act) return;
      if(act.type==='create') act.pl.remove();
      else if(act.type==='delete'){
        const pl=document.createElementNS(svg.namespaceURI,'polyline');
        pl.setAttribute('points',act.points);
        pl.setAttribute('marker-end', 'url(#arrowhead)'); // Ensure arrowhead is restored
        pl.dataset.a=act.a; pl.dataset.b=act.b;
        svg.appendChild(pl); attachLinkListener(pl);
      }
      redoStack.push(act); updateButtons();
    };
    redoBtn.onclick = ()=>{
      const act=redoStack.pop(); if(!act) return;
      if(act.type==='create') svg.appendChild(act.pl);
      else if(act.type==='delete') act.pl.remove();
      undoStack.push(act); updateButtons();
    };

    // Drag ‚Üí Node creation
    draggables.forEach(d=>{
      d.ondragstart = e=> e.dataTransfer.setData('text/plain', d.dataset.type);
    });
    container.ondragover = e=> e.preventDefault();
    container.ondrop = e=>{
      e.preventDefault();
      const type = e.dataTransfer.getData('text/plain');
      const r=container.getBoundingClientRect();
      const rawX=(e.clientX-r.left+container.scrollLeft)/scale;
      const rawY=(e.clientY-r.top+container.scrollTop)/scale;
      const x=Math.round(rawX/gridSize)*gridSize;
      const y=Math.round(rawY/gridSize)*gridSize;
      createNode(type,x,y);
    };

    // Node creation & drag
    // Make createNode, drawLink, calculateFlowchartPath, updateLinks global for tests
    window.createNode = function(type,x,y){ // Assign to window
      const n=document.createElement('div');
      n.className='node'; n.id='n'+(++nodeCounter); // nodeCounter is from the outer scope
      n.textContent=type; n.style.left=`${x}px`; n.style.top=`${y}px`;
      panzoom.appendChild(n);

      Array.from(svg.children).forEach(pl => {
        if (pl.tagName.toLowerCase() === 'polyline' && pl.dataset.a && pl.dataset.b) { 
          const na = document.getElementById(pl.dataset.a);
          const nb = document.getElementById(pl.dataset.b);
          if (na && nb) {
            const pathPoints = window.calculateFlowchartPath(na, nb); // use window.
            pl.setAttribute('points', pathPoints.map(p => p.join(',')).join(' '));
          }
        }
      });

      n.onclick = e=>{
        e.stopPropagation();
        if(unlinkMode){
          Array.from(svg.children)
            .filter(l=>l.dataset.a===n.id||l.dataset.b===n.id)
            .forEach(l=>{
              pushAction({type:'delete',a:l.dataset.a,b:l.dataset.b,points:l.getAttribute('points'),pl:l});
              l.remove();
            });
          return;
        }
        if(!drawMode) return;
        if(!startNode){ startNode=n; n.classList.add('selected'); }
        else if(startNode!==n){
          window.drawLink(startNode,n); // use window.
          startNode.classList.remove('selected'); startNode=null;
        }
      };

      let offX, offY;
      n.onpointerdown = e=>{
        if(drawMode||unlinkMode) return;
        e.preventDefault();
        const rect=n.getBoundingClientRect();
        offX=(e.clientX-rect.left)/scale;
        offY=(e.clientY-rect.top)/scale;
        n.setPointerCapture(e.pointerId);
        n.onpointermove = drag;
        n.onpointerup   = drop;
      };
      function drag(e){
        const r=container.getBoundingClientRect();
        const rawX=(e.clientX-r.left+container.scrollLeft)/scale-offX;
        const rawY=(e.clientY-r.top+container.scrollTop)/scale-offY;
        const x=Math.round(rawX/gridSize)*gridSize;
        const y=Math.round(rawY/gridSize)*gridSize;
        n.style.left=`${x}px`; n.style.top=`${y}px`;
        window.updateLinks(n); // use window.
      }
      function drop(e){
        n.releasePointerCapture(e.pointerId);
        n.onpointermove=null; n.onpointerup=null;
      }
    }; // End of window.createNode

    window.calculateFlowchartPath = function(sourceNode, targetNode) { // Assign to window
      const sourceX = parseFloat(sourceNode.style.left) + 25;
      const sourceY = parseFloat(sourceNode.style.top) + 25;
      const targetX = parseFloat(targetNode.style.left) + 25;
      const targetY = parseFloat(targetNode.style.top) + 25;

      const pathHV = [[sourceX, sourceY], [targetX, sourceY], [targetX, targetY]];
      const pathVH = [[sourceX, sourceY], [sourceX, targetY], [targetX, targetY]];

      const path1Blocked = isPathNodeBlocked(pathHV, sourceNode, targetNode);
      if (!path1Blocked) {
        return pathHV;
      }
      const path2Blocked = isPathNodeBlocked(pathVH, sourceNode, targetNode);
      if (!path2Blocked) {
        return pathVH;
      }
      return pathHV;
    }; // End of window.calculateFlowchartPath

    function isPathNodeBlocked(path, ignoreNodeA, ignoreNodeB){ // Not assigned to window, used internally
      const otherNodes = Array.from(panzoom.querySelectorAll('.node'))
                        .filter(n => n !== ignoreNodeA && n !== ignoreNodeB)
                        .map(n => {
                          const L = parseFloat(n.style.left);
                          const T = parseFloat(n.style.top);
                          return { l: L, r: L + 50, t: T, b: T + 50 }; 
                        });
      for (let i = 0; i < path.length - 1; i++) {
        const [x1, y1] = path[i];
        const [x2, y2] = path[i+1];
        const isVerticalSegment = x1 === x2;
        const minX = Math.min(x1, x2);
        const maxX = Math.max(x1, x2);
        const minY = Math.min(y1, y2);
        const maxY = Math.max(y1, y2);
        for (const nodeRect of otherNodes) {
          const overlapsX = maxX > nodeRect.l && minX < nodeRect.r; 
          const overlapsY = maxY > nodeRect.t && minY < nodeRect.b; 
          if (isVerticalSegment) {
            if (x1 >= nodeRect.l && x1 <= nodeRect.r && overlapsY) return true;
          } else { 
            if (y1 >= nodeRect.t && y1 <= nodeRect.b && overlapsX) return true;
          }
        }
      }
      return false; 
    }

    window.drawLink = function(a,b){ // Assign to window
      const pathPoints = window.calculateFlowchartPath(a,b); // use window.
      const pts = pathPoints.map(p=>p.join(',')).join(' ');
      const pl=document.createElementNS(svg.namespaceURI,'polyline');
      pl.setAttribute('points',pts);
      pl.setAttribute('marker-end', 'url(#arrowhead)'); 
      pl.dataset.a=a.id; pl.dataset.b=b.id;
      svg.appendChild(pl);
      attachLinkListener(pl);
      pushAction({type:'create',pl});
    }; // End of window.drawLink

    function segmentsIntersect(ax,ay,bx,by,cx,cy,dx,dy){
      const ccw=(px,py,qx,qy,rx,ry)=>(ry-py)*(qx-px) > (qy-py)*(rx-px);
      return ccw(ax,ay,cx,cy,dx,dy)!==ccw(bx,by,cx,cy,dx,dy)
          && ccw(ax,ay,bx,by,cx,cy)!==ccw(ax,ay,bx,by,dx,dy);
    }

    function attachLinkListener(pl){
      pl.onclick = e=>{
        e.stopPropagation();
        if(unlinkMode){
          pushAction({type:'delete',a:pl.dataset.a,b:pl.dataset.b,points:pl.getAttribute('points'),pl});
          pl.remove();
        }
      };
    }

    window.updateLinks = function(node){ // Assign to window
      Array.from(svg.children).forEach(pl=>{
        if(pl.dataset.a===node.id||pl.dataset.b===node.id){
          if (pl.tagName.toLowerCase() !== 'polyline') return; // Skip non-polylines like <defs>
          const na=document.getElementById(pl.dataset.a);
          const nb=document.getElementById(pl.dataset.b);
          if (na && nb) { // Ensure both nodes still exist
            const pathPoints = window.calculateFlowchartPath(na, nb); // use window.
            pl.setAttribute('points', pathPoints.map(p => p.join(',')).join(' '));
          }
        }
      });
    }; // End of window.updateLinks

    updateButtons();
  })();
  </script>
  <script>
  window.addEventListener('load', () => {
  console.log('--- Starting Injected Tests ---');

  const testResults = [];
  let nodeCounterForTest = 0; // Use internal counter to predict node IDs

  function logTest(description, passed, details = '') {
    const result = `TEST [${passed ? 'PASS' : 'FAIL'}]: ${description}${details ? ` - Details: ${details}` : ''}`;
    console.log(result);
    testResults.push({ description, passed, details });
  }

  // Helper to get the next expected node ID
  // This assumes we know the initial nodeCounter value from the main script or can infer it.
  // For simplicity, we'll assume the main script's nodeCounter starts at 0 and increments BEFORE assigning ID.
  // So, the first node created by main script is n1, second is n2 etc.
  // Our test nodes will follow this sequence.
  // We need to know what `nodeCounter` is *after* the main script runs but *before* our tests.
  // Let's try to get it from the global scope if possible, or make an assumption.
  // For this test, we'll assume our test nodes are the first ones if the canvas is cleared,
  // or we'll just use the IDs returned by our own createNode calls.
  // The main script's nodeCounter is not directly exposed.
  // The `createNode` function in main script returns the node object.
  // We'll rely on the `createNode` function from the main script.

  // --- Initial State Checks ---
  console.log('--- Running: Initial State Checks ---');
  try {
    const svgElement = document.querySelector('.panzoom svg');
    logTest('SVG element exists', !!svgElement);

    const markerElement = svgElement ? svgElement.querySelector('#arrowhead') : null;
    logTest('Arrowhead marker #arrowhead exists within SVG', !!markerElement);
    if (markerElement) {
        logTest('Arrowhead marker has correct markerWidth', markerElement.getAttribute('markerWidth') === '10');
        logTest('Arrowhead marker has correct markerHeight', markerElement.getAttribute('markerHeight') === '7');
        logTest('Arrowhead marker has correct refX', markerElement.getAttribute('refX') === '8');
        logTest('Arrowhead marker has correct refY', markerElement.getAttribute('refY') === '3.5');
        logTest('Arrowhead marker has correct orient', markerElement.getAttribute('orient') === 'auto');
        const polygon = markerElement.querySelector('polygon');
        logTest('Arrowhead marker contains a polygon', !!polygon);
        if (polygon) {
            logTest('Arrowhead polygon has correct points', polygon.getAttribute('points') === '0 0, 10 3.5, 0 7');
            logTest('Arrowhead polygon has correct fill', markerElement.getAttribute('fill') === '#000'); // Fill is on marker
        }
    }


    logTest('typeof window.calculateFlowchartPath === "function"', typeof window.calculateFlowchartPath === 'function');
    logTest('typeof window.drawLink === "function"', typeof window.drawLink === 'function');
    logTest('typeof window.updateLinks === "function"', typeof window.updateLinks === 'function');
    logTest('typeof window.createNode === "function"', typeof window.createNode === 'function'); // Assuming createNode is global
    logTest('Undo button exists', !!document.getElementById('undoBtn'));
    logTest('Redo button exists', !!document.getElementById('redoBtn'));
    logTest('Clear button exists', !!document.getElementById('clearCanvas'));
    
    // Ensure canvas is clear for subsequent tests for predictability
    if (document.getElementById('clearCanvas')) {
        document.getElementById('clearCanvas').click(); 
        console.log('Canvas cleared for subsequent tests.');
    } else {
        console.warn('Clear canvas button not found; tests might be affected by prior state.');
    }
    // Wait a moment for clearCanvas to take effect (if it has async parts, though it looks sync)
    // Directly manipulating nodeCounter is tricky as it's scoped. We'll rely on createNode's return.

  } catch (e) {
    logTest('Initial State Checks block failed', false, e.toString());
  }

  // --- Simulated Node and Link Creation (Programmatic) ---
  console.log('--- Running: Simulated Node and Link Creation ---');
  let testNode1, testNode2, linkElement;
  let n1_id_actual, n2_id_actual;

  try {
    // Programmatically call global createNode(type, x, y)
    // The global createNode function in livemockup.html does not return the node or its ID directly.
    // It appends 'n'+(++nodeCounter). We need to predict this.
    // Let's modify our test to grab the nodes after creation.
    
    // Assuming nodeCounter is 0 after clearCanvas
    window.createNode('T1', 100, 100); // Expected to be n1
    testNode1 = document.getElementById('n1');
    n1_id_actual = testNode1 ? testNode1.id : null;
    logTest('Node 1 (T1) created and found by predicted ID n1', !!testNode1 && testNode1.textContent === 'T1');

    window.createNode('T2', 300, 200); // Expected to be n2
    testNode2 = document.getElementById('n2');
    n2_id_actual = testNode2 ? testNode2.id : null;
    logTest('Node 2 (T2) created and found by predicted ID n2', !!testNode2 && testNode2.textContent === 'T2');
    
    const nodesInPanzoom = document.querySelectorAll('.panzoom .node');
    logTest('Two div.node elements are in panzoom', nodesInPanzoom.length === 2, `Found ${nodesInPanzoom.length}`);

    if (testNode1 && testNode2) {
      window.drawLink(testNode1, testNode2); // Use the actual node elements
      
      // Find the link - assumes only one link exists
      linkElement = document.querySelector('.panzoom svg polyline');
      logTest('SVG polyline created for link', !!linkElement);

      if (linkElement) {
        logTest('Polyline has dataset.a === n1_id_actual', linkElement.dataset.a === n1_id_actual, `Expected ${n1_id_actual}, got ${linkElement.dataset.a}`);
        logTest('Polyline has dataset.b === n2_id_actual', linkElement.dataset.b === n2_id_actual, `Expected ${n2_id_actual}, got ${linkElement.dataset.b}`);
        logTest('Polyline has marker-end attribute "url(#arrowhead)"', linkElement.getAttribute('marker-end') === 'url(#arrowhead)');
        
        const points = linkElement.getAttribute('points');
        logTest('Polyline points attribute is non-empty', !!points && points.length > 0);
        if (points) {
          const numPairs = points.split(' ').length;
          logTest('Polyline points attribute has at least 3 coordinate pairs', numPairs >= 3, `Found ${numPairs} pairs`);
        }
      }
    } else {
      logTest('Skipping link creation tests as nodes were not found', false);
    }
  } catch (e) {
    logTest('Simulated Node and Link Creation block failed', false, e.toString());
  }

  // --- Undo/Redo Link Creation (Programmatic) ---
  console.log('--- Running: Undo/Redo Link Creation ---');
  try {
    if (!linkElement || !linkElement.parentElement) { // Check if linkElement is valid and in DOM
      logTest('Skipping Undo/Redo: Link from previous step not found or already removed.', false);
    } else {
      const undoBtn = document.getElementById('undoBtn');
      const redoBtn = document.getElementById('redoBtn');
      
      if (!undoBtn || !redoBtn) {
          logTest('Undo/Redo buttons not found', false);
      } else {
          const linkDatasetA = linkElement.dataset.a;
          const linkDatasetB = linkElement.dataset.b;

          undoBtn.onclick(); // Simulate undo
          // Check if the specific link is gone. Query for it again.
          const linkAfterUndo = document.querySelector(`.panzoom svg polyline[data-a="${linkDatasetA}"][data-b="${linkDatasetB}"]`);
          logTest('Link removed from SVG after undo', !linkAfterUndo);

          redoBtn.onclick(); // Simulate redo
          const linkAfterRedo = document.querySelector(`.panzoom svg polyline[data-a="${linkDatasetA}"][data-b="${linkDatasetB}"]`);
          logTest('Link restored in SVG after redo', !!linkAfterRedo);
          if (linkAfterRedo) {
            logTest('Restored link has marker-end attribute', linkAfterRedo.getAttribute('marker-end') === 'url(#arrowhead)');
          }
      }
    }
  } catch (e) {
    logTest('Undo/Redo Link Creation block failed', false, e.toString());
  }

  console.log('--- Injected Tests Finished ---');
  // In a real browser, you could send results to a server or display them.
  // Here, they are just in the console.
});
  </script>
</body>
</html>
